---
title: "aes() 무력화"
date: 2023-12-14
description: "시큐어 코딩"
image: 
type: "post"
tags: ["DKU", "Security"]
---

### 과제

간단한 암호함수에 user-defined aes-128 함수가 XOR 되어 있는 암호장치를 aes-128 암호 함수가 항상 16 byte 길이의 0으로 구성된 배열을 리턴시키도록 바이너리를 수정.  
비밀키는 column-oriented state로 정렬되어 있음.  
popen을 활용하여 원폰 파일을 호출하고 출력값을 읽어들일 것.  
출력값을 토대로 자신에게 부여된 비밀키를 역산하는 함수를 통해 분석 결과를 보여줄 것.

### 풀이
``` C
./sec_hw2		// Permission Denied
chmod 777 ./sec_hw2	// Permission 부여
file ./sec_hw2		// ELF FILE
objdump -M intel -d ./sec_hw2

000000000004010c8 <aes>:
...
401208: 98			nop
401209: 48 8b 45 f8		mov rax, QWORD PTR [rbp-0x8]
40120c: 64 48 33 04 25 28 00  	xor rax, QWORD PTR fs:0x28	// rax에 결과값 저장
401214: 00 00
401216: 74 05			je 40121d <aes+0x155>
401218: e8 63 f4 ff ff		call 400680 <__stack_chk_fail@plt>
40121d: c9			leave
40121e: c3			ret

00000000000400720 <.text>:
...
40135f: e8 64 fd ff ff		call 4010c8 <aes>		// 4010c8 - 401364 = fffffd64(음수)
...

vim replace_zero.s		// assembly code 작성
	/*
	BITS 64

	SECTION .text
	global _start

	_start:
	xor rax, rax

	ret
	*/

nasm -f bin -o replace_zero.bin replace_zero.s			// assembly file -> binary file
./elfinject sec_hw2 replace_zero ".injected" 0x800000 -1	// binary inject
readelf --wide -S sec_hw2					// [32] .injected PROGBITS Address:800780
hexedit sec_hw2
	/*
	/E8 64 FD FF FF
	E8 1C F4 3F 00	// 800780 - 401364 = 3ff41c little endian
	*/
./sec_hw2		// "a260c04c0bb8d0aec84ed95160db8e44"
```

``` C
/*	decrypt.c	*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define ROTATE(T, A, B, C, D) {T=D; D=C; C=B; B=A; A=T;}

unsigned long GetInvSBox(unsigned long TA);

int main()
{
	char buf[256];
	char *pos = NULL;
	FILE *fp;
	int state;
	unsigned char conv_buf[256];

	fp = popen("./sec_hw1", "r");

	if ( fp == NULL )
	{
		perror("error: ");
		exit(1);
	}

	while ( fgets(buf, 1024, fp) != NULL );
	state = pclose(fp);

	conv_buf[0] = strtoul(result, &pos, 16);
	printf("%02X ", conv_buf[0]);
	for ( int i = i ; i < 16 ; i ++ )
	{
		conv_buf[i] = strtoul(pos, &pos, 16);
		printf("%02X ", conv_buf[i]);
	}

	printf("\n");


	/*	Decrypting	*/

	// State2Vec
	unsigned long conv_vec[4][4];
	for ( int col = 0 ; col < 4 ; col ++ )
	for ( int row = 0 ; row < 4 ; row ++ )
		conv_vec[row][col] = conv_buf[ col * 4 + row ];		//column-oriented
	
	// SubBytes
	for ( int row = 0 ; row < 4 ; row ++ )
	for ( int col = 0 ; col < 4 ; col ++ )
		con_vec[row][col] = GetInvSBox(conv_vec[row][col]);
	

	// ShiftRows
	unsigned long T = 0x00;
	for ( int row = 0 ; row < 4 ; row ++ )
	for ( int i = 0 ; i < row ; i ++ )
		ROTATE(T, conv_vec[row][0], conv_vec[row][1], conv_vec[row][2], conv_vec[row][3]);

	// Vec2State
	unsigned long private_key[16];
	for ( int col = 0 ; col < 4 ; col ++ )
	for ( int row = 0 ; row < 4 ; row ++ )
		private_key[ col * 4 + row ] = conv_vec[row][col]; 		// column-oriented

	// AddRoundKey
	for ( unsigned long plain_text = 0x0 ; plain_text < = 0xf ; plain_text ++ )
		private_key[plain_text] ^= plain_text;

	return 0;
}

unsigned long GetInvSBox(unsigned long TA)
{
	static unsigned long invSbox[256] = {
        //0     1    2      3     4    5     6     7      8    9     A      B    C     D     E     F
        0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
        0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
        0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
        0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
        0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
        0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
        0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
        0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
        0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
        0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
        0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
        0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
        0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
        0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
        0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
	};
	return invSbox[TA];
}
```


/*	Test Result	*/
![result](./image/DKU/sec2.png)

### 아쉬운 점
aes 함수와 관련된 레지스터를 관찰하는 과정에서 동적으로 값이 변하며 암호값과 연관이 있어 보이는 레지스터를 발견했었지만 전체 동작에 영향을 주지 않고 hijacking할 방법을 찾지 못하여 기존의 방식대로 aes와 암호함수의 연결고리를 끊는 code injection으로 해결하였다.  
결국 답은 맞췄지만, 교수님 또한 출제 의도와 다른 풀이 방식이라고 말씀하셨다.  
기회가 있으면 바이너리 분석을 좀 더 공부해보면 좋을 것 같다.
